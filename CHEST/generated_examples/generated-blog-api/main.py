"""Blog API - Generated by Statement-to-Reality System"""
from fastapi import FastAPI, Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
from typing import List
from datetime import datetime
import jwt
import uuid

app = FastAPI(title="Blog API")

# Models
class PostCreate(BaseModel):
    title: str
    content: str

class Post(BaseModel):
    id: str
    title: str
    content: str
    author_id: str
    created_at: datetime

class CommentCreate(BaseModel):
    content: str

class Comment(BaseModel):
    id: str
    post_id: str
    content: str
    created_at: datetime

class UserCreate(BaseModel):
    username: str
    password: str

# In-memory storage
posts_db = {}
comments_db = {}
users_db = {}
SECRET = "secret"

# Auth
security = HTTPBearer()

def get_user(creds: HTTPAuthorizationCredentials = Depends(security)) -> str:
    try:
        return jwt.decode(creds.credentials, SECRET, algorithms=["HS256"])["uid"]
    except:
        raise HTTPException(401, "Invalid token")

@app.post("/auth/register")
def register(user: UserCreate):
    uid = str(uuid.uuid4())
    users_db[uid] = {"username": user.username, "password": user.password}
    token = jwt.encode({"uid": uid}, SECRET)
    return {"token": token}

@app.post("/auth/login")
def login(user: UserCreate):
    for uid, u in users_db.items():
        if u["username"] == user.username and u["password"] == user.password:
            return {"token": jwt.encode({"uid": uid}, SECRET)}
    raise HTTPException(401, "Bad credentials")

# Posts
@app.post("/posts", response_model=Post)
def create_post(post: PostCreate, uid: str = Depends(get_user)):
    pid = str(uuid.uuid4())
    p = Post(id=pid, title=post.title, content=post.content, author_id=uid, created_at=datetime.utcnow())
    posts_db[pid] = p.dict()
    return p

@app.get("/posts", response_model=List[Post])
def list_posts(skip: int = 0, limit: int = 10):
    return [Post(**p) for p in list(posts_db.values())[skip:skip+limit]]

@app.get("/posts/{pid}", response_model=Post)
def get_post(pid: str):
    if pid not in posts_db:
        raise HTTPException(404)
    return Post(**posts_db[pid])

@app.delete("/posts/{pid}")
def delete_post(pid: str, uid: str = Depends(get_user)):
    if pid not in posts_db:
        raise HTTPException(404)
    if posts_db[pid]["author_id"] != uid:
        raise HTTPException(403)
    del posts_db[pid]
    return {"ok": True}

# Comments
@app.post("/posts/{pid}/comments", response_model=Comment)
def add_comment(pid: str, c: CommentCreate, uid: str = Depends(get_user)):
    if pid not in posts_db:
        raise HTTPException(404)
    cid = str(uuid.uuid4())
    comment = Comment(id=cid, post_id=pid, content=c.content, created_at=datetime.utcnow())
    comments_db[cid] = comment.dict()
    return comment

@app.get("/posts/{pid}/comments", response_model=List[Comment])
def get_comments(pid: str):
    return [Comment(**c) for c in comments_db.values() if c["post_id"] == pid]

@app.get("/health")
def health():
    return {"status": "ok", "posts": len(posts_db), "comments": len(comments_db)}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
