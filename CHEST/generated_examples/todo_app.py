"""
Generated by Statement-to-Reality System
Statement: "Create a todo application with user authentication and real-time updates"
"""
from fastapi import FastAPI, HTTPException, Depends, WebSocket, WebSocketDisconnect
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel
from typing import List, Optional
from datetime import datetime
import jwt
import uuid

app = FastAPI(title="Todo App", description="Generated from natural language")

# ============ MODELS ============
class User(BaseModel):
    id: str = None
    username: str
    email: str
    
class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class Todo(BaseModel):
    id: str = None
    title: str
    description: Optional[str] = None
    completed: bool = False
    user_id: str = None
    created_at: datetime = None

class TodoCreate(BaseModel):
    title: str
    description: Optional[str] = None

# ============ IN-MEMORY STORAGE ============
users_db = {}
todos_db = {}
tokens_db = {}
SECRET_KEY = "statement-to-reality-secret"

# ============ AUTH SERVICE ============
security = HTTPBearer()

def create_token(user_id: str) -> str:
    token = jwt.encode({"user_id": user_id, "exp": datetime.utcnow().timestamp() + 86400}, SECRET_KEY, algorithm="HS256")
    tokens_db[token] = user_id
    return token

def verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)) -> str:
    token = credentials.credentials
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        return payload["user_id"]
    except:
        raise HTTPException(status_code=401, detail="Invalid token")

# ============ USER ENDPOINTS ============
@app.post("/auth/register", response_model=dict)
async def register(user: UserCreate):
    user_id = str(uuid.uuid4())
    users_db[user_id] = {"id": user_id, "username": user.username, "email": user.email, "password": user.password}
    token = create_token(user_id)
    return {"user_id": user_id, "token": token}

@app.post("/auth/login", response_model=dict)
async def login(username: str, password: str):
    for user_id, user in users_db.items():
        if user["username"] == username and user["password"] == password:
            token = create_token(user_id)
            return {"user_id": user_id, "token": token}
    raise HTTPException(status_code=401, detail="Invalid credentials")

@app.get("/users/me", response_model=User)
async def get_me(user_id: str = Depends(verify_token)):
    if user_id not in users_db:
        raise HTTPException(status_code=404, detail="User not found")
    return User(**users_db[user_id])

# ============ TODO ENDPOINTS ============
@app.post("/todos", response_model=Todo)
async def create_todo(todo: TodoCreate, user_id: str = Depends(verify_token)):
    todo_id = str(uuid.uuid4())
    new_todo = {
        "id": todo_id,
        "title": todo.title,
        "description": todo.description,
        "completed": False,
        "user_id": user_id,
        "created_at": datetime.utcnow()
    }
    todos_db[todo_id] = new_todo
    await broadcast_update("todo_created", new_todo)
    return Todo(**new_todo)

@app.get("/todos", response_model=List[Todo])
async def list_todos(user_id: str = Depends(verify_token)):
    user_todos = [Todo(**t) for t in todos_db.values() if t["user_id"] == user_id]
    return user_todos

@app.patch("/todos/{todo_id}/complete", response_model=Todo)
async def complete_todo(todo_id: str, user_id: str = Depends(verify_token)):
    if todo_id not in todos_db:
        raise HTTPException(status_code=404, detail="Todo not found")
    if todos_db[todo_id]["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="Not your todo")
    todos_db[todo_id]["completed"] = True
    await broadcast_update("todo_completed", todos_db[todo_id])
    return Todo(**todos_db[todo_id])

@app.delete("/todos/{todo_id}")
async def delete_todo(todo_id: str, user_id: str = Depends(verify_token)):
    if todo_id not in todos_db:
        raise HTTPException(status_code=404, detail="Todo not found")
    if todos_db[todo_id]["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="Not your todo")
    del todos_db[todo_id]
    await broadcast_update("todo_deleted", {"id": todo_id})
    return {"deleted": todo_id}

# ============ WEBSOCKET (REAL-TIME) ============
connected_clients: List[WebSocket] = []

async def broadcast_update(event: str, data: dict):
    for client in connected_clients:
        try:
            await client.send_json({"event": event, "data": data})
        except:
            pass

@app.websocket("/ws")
async def websocket_endpoint(websocket: WebSocket):
    await websocket.accept()
    connected_clients.append(websocket)
    try:
        while True:
            data = await websocket.receive_text()
            # Echo back for now
            await websocket.send_json({"echo": data})
    except WebSocketDisconnect:
        connected_clients.remove(websocket)

# ============ HEALTH ============
@app.get("/health")
async def health():
    return {
        "status": "healthy",
        "components": ["AuthService", "UserService", "TodoService", "WebSocketHandler"],
        "users": len(users_db),
        "todos": len(todos_db),
        "ws_clients": len(connected_clients)
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
